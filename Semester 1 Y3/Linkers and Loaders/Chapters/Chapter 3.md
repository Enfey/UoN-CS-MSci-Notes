# What are Object files?
Compilers + assemblers create object files containing the generated binary code and data, and metadata for a given source file. Linkers combine multiple object files into one file; loaders take coalesced object files and load them into memory. There are many object file formats.

## What Goes into an object file?
Contains 5 kinds of basic info(can contain more, but this is minimum usually). 
1. *Header Information*: Overall metadata for file e.g., size of the code, name of source file translated from, and creation date.
2. *Object Code* - Binary/Hex instructions and data generated by a compiler or assembler
3. *Relocation Information* - list of places in object code that need to be modified that need to be modified when linker assigns new addresses to the object code
4. *Symbols* - These include global symbols defined in this module and symbols to be imported from other modules or defined by the linker.
5. *Debugging Information* - this information is not required for linking but is useful to a debugger. Includes info such as source file and line number information, local symbols and descriptions of data structures used by the object code e.g., C struct definitions.

### Designing an Object Format
Design is a compromise driven by the use case of a given object file.
1. A file may be **linkable**, used as input by a link editor or linking loader
	A linkable file contains extensive symbol and relocation information needed by linker along with the object code. The object code is often divided up into many small logical segments that will be treated differently by the linker.
2. A file may be **executable**, capable of being loaded into memory and run as a program
	An executable file contains object code - usually page aligned to permit the file to be mapped into physical address space - but doesn't need any symbol info unless doing run-time dynamic linking, little or no relocation info too. The object code is a single large segment or small set of segments that directly reflect the hardware execution environment (most often read only vs read/write pages).
3. A file may be **loadable**, capable as being loaded into memory as a library along with a program.
	Depending on details of a systems runtime environment, a loadable file may consist solely of object code, or it may contain complete symbol and relocation information to permit run-time linking. 
Amongst these applications, there is conflict. For example, the logically oriented grouping of linkable file segments rarely matches the hardware oriented grouping of executable segments, which prioritises separating read-only code from read-write data pages to save on I/O cycles. 


### DOS COM - The Null Object Format
The DOS COM format is characterised by its extreme simplicity, consisting of literally nothing other that runnable binary code. It contrasts with other formats by having little or no information beyond the object code. The design of the .COM format relies on the segmented architecture of the x86 processor. 

When the OS runs a COM file, it merely loads the contents into a chunk of free memory starting always starting at offset 0x100 from the segment base (0-FF are reserved, and hold command line args and other parameters). 

The system also sets all x86 segment registers (code segment, data segment) to point to the base of the Program Segment Prefix, which occupies the addresses 0-FF. The stack pointer is set to the highest usable address in the segment to accommodate the downward-growing stack. 

We need no relocation, as the program addresses are interpreted as offsets relative to the segments, which are all aligned to the base address of the PSP. Although this leads to an issue in that .COM is only suitable for programs that will fit in a single segment as it uses the tiny model. If a program exceeds this size, it became the programmers responsibilities for performing any necessary address fixups. E.g., identify target address, and substitute the original single instruction with an intermediate table lookup or sequence of instructions to construct full 32 bit address.
### Unix A.Out Files
More traditional object file format used on Unix systems. It is associated with systems that create a new process with an empty address space, thus programs can be linked to start at a fixed address and require no relocation at load time. 

In the simplest case, an $a.out$ file consists of a **small header** followed by the executable code, traditionally called the text section, and initial values for static data. 

$\text{Not Relevant, but interesting}$:

Historically, PDP had only 16 bit addressing, 64KB program size limit, became too small, so later models provided separate address spaces for code (I for instruction space) and data (d space), contain 64KB of code, and 64KB of data. Compilers, assemblers, and linker modified to create two-section object files, with code located in first section, and data in second section; program loader loaded first section into process's I space and second into the D space. 

Separate I and D spaces had another performance advantage, as program couldn't change its own I space, could share a single copy of program code while keeping separate copies of the program's data. On a timeshare system like UNIX, multiple copies of the shell and network daemons are common, shared program code thus saved considerable memory. Only 286 and 386 still use separate addressing for code and data. Now use shared read-only code pages in conjunction with shared memory, much more efficient. Means that linker formats at least mark read-only versus read-write sections to enable better frame/page backing (UNIX confusingly calls file sections segments, so use that term during the duration of UNIX file formats.)

#### Header of an A.Out file
The header somewhat varies from one version of UNIX to another, but the version in BSD UNIX is typical:
$$
\begin{gathered}
\text{int a\_magic //magic number} \\
\text{int a\_text //text segment size} \\
\text{int a\_data //initialised data size}  \\
\text{int a\_bss //uninitialised data size} \\
\text{int a\_syms //symbol table size} \\
\text{int a\_entry //entry point} \\
\text{int a\_trsize //text relocation size} \\
\text{int a\_drsize//data relocation size} \\
\end{gathered}
$$
The magic number $a\_magic$ indicates what kind of executable file this is. Different magic numbers tell the OS to load the file into memory differently.

The text and segment sizes $a\_text$ and $a\_data$ are the sizes in bytes of the read only code and read/write data that follow the header. Because UNIX automatically initialises newly allocated memory to zero, any data with an initial content of 0 or whose contents don't matter need not be present in the $a.out$ file. 

The $a\_entry$ field gives the starting address of the program, while $a\_syms, a\_trsize,$ and $a\_drsize$ specify how much symbol table and relocaiton information follows the data segment/section in the file. Programs that have been linked and are ready to run need neither symbol nor relocation information, so these fields are zero in runnable files barring symbols for the debugger. 

#### Interactions with virtual memory : NMAGIC, ZMAGIC, QMAGIC
The process involved when the OS loads and starts a simple 2 segment a.out file is straightforward:
1. Read the a.out header to get the segment sizes
2. Check to see if there's already a shareable code segment for this file. If so, map that segment into the process's address space. If not, create one, and map the text segment from the program into the process's address space. 
3. Create a private data segment large enough for the combined data and bss, map it into the process, and read the data segment from the file into the data segment. Zero out the bss segment. Place directly after text segment, not page-aligned. 
4. Create and map in a stack segment, often at top address of process as stack grows downward. Place arguments from the command line or the calling program on the stack.
5. Set registers appropriately and jump to the starting address. 
![[Pasted image 20251024192610.png]]
This scheme is known as NMAGIC, and was used until paging became prevalent.

When say map here, don't mean true file mapping, more so actual copying. 

##### ZMAGIC
Improvement to NMAGIC to leverage virtual memory and paging capabilities, and enable file mapping. ZMAGIC structural changes included the requirement of segments to be aligned on page boundaries:
- The a.out header is expanded to match a page size
- The text segments size is rounded up to the next page boundary
- The data segment size does not need rounding up as the BSS segment logically follows the data segment and is zeroed by the program loader anyway.
Because the a.out file is already stored on disk itself, the object file can be mapped into the process's address space.

OS allocates virtual address space for the program according to header size info. Instead of copying the programs content immediately, uses a.out file as paging disk i.e., backing store with on-demand paging. Marks pages in mapped segments as not present, so page faults generated, page faults handled by paging system by backing up pages with the necessary 4KB aligned chunks of the file on disk, moving them into corresponding physical page frames. Text pages mapped as read-only, data mapped as copy-on-write.

Speeds up program startup, and reduce unneeded paging, but does it at cost of wasting memory space. The gap between text and data often wastes 2KB on average, and the header is only 32 bytes long but expanded to be page aligned and separate from the text section, so is further wasting roughly 4KB.
![[Pasted image 20251024195659.png]]


##### QMAGIC
Compact pageable format developed to overcome the drawback of ZMAGIC wasting disk and memory space due to expanded headers and padding. 

The QMAGIC format optimises space and safety via specific loading and structural conventions. Considers the header to be part of the text segment. 

The kernel maps the program into memory such that the header + beginning of text segment are mapped starting at virtual address $page\_size$, leaving the first virtual page unmapped, letting null pointer dereference trigger a fault instead of landing in mapped code/data.

This is the key change from zmagic, other than considering the header to be part of the text segment, and also rounding up the data segment to a full page, so the system can easily memory map file chunks to virtual address space pages.

The last page of the data segment is padded out with zeros for bss data; if more bss data exists than fits in the padding area, the header contains the size of the remaining bss area to allocate. 

The header is used to create the logical address space and enforce constraints e.g., the first page will remain unmapped in QMAGIC. Then when the program starts, page faults are generated and the paging system enforces demand paging for the chunks of the file, and memory maps the file into the physical frames for the corresponding pages!

### DOS EXE Files
The a.out format is adequate for systems that assign a fresh, private logical address space to each process as it assumes a program is linked to load at one fixed virtual address. 

However, this is not the case for all systems. Some load all the programs into the same virtual address space. Others give each program its own address space, but randomise the starting address, and other portions of the process, aka address space layout randomisation, where code, data, stack, shared libraries have their addresses randomised at load time.

As seen with DOS, loads program into a contiguous chunk of available real-mode memory. If the program doesn't fit in one 64KB segment, the program has to use explicit section numbers to address the program and data relatively. 

(necessary info to understand this)
*x86 segment registers hold a 16 bit value - this is not a raw address, it is a paragraph number. So a segment value of `0x1234` means the base of that segment is:  0x1234 ≪ 4=0x12340. This was done because the chip needed to address **1 MB of physical memory** (20 bits of address lines). Including a 16 bit offset, each segment defines a 64KB window of memory in a 1MB memory space.* 

Linker lays out sections into image and writes stored segment values (paragraph numbers, representing 16 byte units) wherever a segment base must be referenced(far pointers, seg symbol). Those stored segment values are relative to the image base = paragraph 0. Offsets are computed relative to segment base. 

DOS loader picks a real load paragraph $L$ where the image is to be placed, copies the image intact to memory at address ($L << 4$ ), and for each relocation entry, it reads the 16 bit stored segment word and replaces it with $stored + L$. Offsets inside sections need not be changed. Shifts image to where actually sits in memory, despite linking to load at address 0. 

The patched segment values exist in memory, and can be put into segment registers as needed. Use $(segment << 4) + offset$ to compute memory address. 

File header contains a number of details:

$$
\begin{gathered}
\text{char signature[2] = "MZ"; // magic number} \\
\text{short lastSize // num bytes used in last block} \\
\text{short nBlocks //number of 512 byte blocks} \\
\text{short hdrsize //fsize of file header in 16 byte paragraphs}
\\
\text{short minalloc //min extra memory to allocate} \\
\text{short maxalloc // max extra memory to allocate} \\
\text{void far *sp // initial stack pointer} \\
\text{short checksum //one's complement checksum of file} \\
\text{void far *ip // initial instruction pointer} \\
\text{short relocpos // location of relocation table} \\
\text{short nooverlay // overlay number, 0 for program} \\
\text{char extra[] //extra material for overlays etc} \\
\text{void far *relocs[] //relocation entries, starts at relocpos}
\end{gathered}
$$
Actual load process is as follows:
1. Read in header and check magic number for validity
2. Find a suitable area of memory. The minalloc and maxalloc fields identify the minimum and maximum number of extra paragraphs of memory to allocate beyond the end of the loaded program (linkers often default to the minimum to size of program's bss and max to 0xFFFF)
3. Create a PSP (control area at head of program)
4. Read in program code immediately after PSP; nblocks and lastsize fields determine length of code.
5. Start reading nreloc fixups at relocpos. For each fixup, add the base address of the program code, $L$ to the segment number in the fixup. 
6. Set the stack pointer to sp, relocate, jump to ip, relocate, start the program. 
### Loadable Formats vs Linkable Formats
Object formats covered thus far were **loadable**. That is, they can be loaded into memory and run directly. Most object files aren't loadable, but rather are intermediate files passed from a compiler or assembler to a linker or library manager. **Linkable** files, we denote these, can be much more complex than loadable ones. Loadable formats have to be simple enough to be directly executed with issues, whilst linkable formats are further processed by a layer of software. 

### Relocatable A.Out - Linkable
Unix always used same general format for both loadable and linkable object files. 

A relocatable a.out file includes several sections necessary for the linking process:
$$
\begin{gathered}
\text{int a\_magic //magic number} \\
\text{int a\_text //text segment size} \\
\text{int a\_data //initialised data size}  \\
\text{int a\_bss //uninitialised data size} \\
\text{int a\_syms //symbol table size} \\
\text{int a\_entry //entry point} \\
\text{int a\_trsize //text relocation size} \\
\text{int a\_drsize//data relocation size} \\
\end{gathered}
$$
The three sections used by the linker are specified by the following fields in the header: $a\_syms$, $a\_trsize$, $a\_drsize$. They follow the main text and data sections in the file, as seen below. 
![[Pasted image 20251026220946.png]]

#### Relocation Entries
Relocation entries in a relocatable $a.out$ file serve 2 functions:
1. Marking places in the code that must be modified due to segment relocation
	Remember! Linkers perform storage allocation: the initial assumption is that all segments reside at logical address 0, or some other default base address, the linker's first major task is reading all input files and grouping corresponding segments to reflect memory layout, respecting alignment and such. This concatenation means original segments must be relocated to new, calculated, non-zero base addresses. This affects both absolute addresses, and inter-segment program references.
2. Marking references to undefined external symbols so the linker knows where to insert the final address value. 
The format of an $a.out$ relocation entry includes
- $Address$ - Specifies the byte offset within the section where the fixup should be applied.
- $r\_length$ - Specifies the width of the relocatable item
- $r\_pcrel$ - Specifies whether relocation should be computed relative to program counter (instruction address) or absolute. 
- $r\_extern$ - Controls the interpretation of the index field - whether relocation references an external symbol or refers to a section/segment.
	- If off, the index tells which segment (text, data, or bss) the item is addressing.
	- If on, this is a reference to an external symbol, and the index is the symbol number in the file's symbol table. 

![[Pasted image 20251026222454.png]]

![[Pasted image 20251026223323.png]]

#### Symbols and Strings
The final section of an a.out file is the symbol table. Each entry is **12 bytes** and describes a single symbol. UNIX compilers permit arbitrarily long identifiers, so the name strings are all in a string table that follows the symbol table.
- **Symbol table**: an array of symbol records, each record containing the symbol's *name offset*, type, debug info, spare value(address)
- **String table**: a blob of NUL-terminated strings containing the actual symbol names, pointed to by offset in symbol records in symbol table.

![[Pasted image 20251026223154.png]]
First item in a symbol table record is the offset/index into the string table, points to NUL-terminated name of the symbol. The type item is a byte long; if the low bit is set, the symbol is global and visible to other modules, non-global if not, non-global non-external symbols not needed for linking technically, but can be used by debuggers. The rest of the bits specify the symbol type, most important types include the following(unix n_type in n list struct)
- **text, data, bss** - if any of these set, tells you where symbol resides
- **abs** - absolute unrelocatable symbol
- **undefined** - symbol is not defined in this module, the external(global) bit must be on. 




### ELF (32 bit)
Executable and Linking format, succeeded $a.out$ for $*nix$ systems. ELF files vary in their format, can be either: **relocatable**, **executable** and **shared object**. Relocatable files are created by compilers and assemblers but need to be processed by linker before running. Executable files have all relocation done and symbols resolved except perhaps shared-library symbols that must be resolved at run-time. Shared objects are shared libraries, containing both symbol information for the linker and directly runnable code for run time. 

ELF files have an unusual dual nature. Compilers, assemblers, and linkers treat the file as a set of logical sections described by a section header table.

Meanwhile, loader treats the file as a set of segments, described by the program header table. A single segment will usually consist of several sections. 
	For example, a loadable read-only segment could contain sections for executable code, read-only data, and symbols for the dynamic linker.

Relocatable files have section tables, executable files have program header tables, and shared objects have both. The sections are intended for further processing by a linker, while the segments are intended to be mapped into memory. 

![[Pasted image 20251027002523.png]]

ELF files all start with a leading ELF header, designed to be decodable regardless of architecture endianness; 
![[Pasted image 20251027172335.png]]

`e_ident[16]` contains the magic number identifying this as an ELF file (127, 0x7F), contains `EI_CLASS` denoting word size, `EI_DATA` denoting endianness, `EI_VERSION` denoting ELF version (always 1), `EI_OSABI`, `EI_ABIVERSION`. Everything here is one byte each, endianness doesn't affect this, so linker can parse this and then determine how to interpret data. 
![[Pasted image 20251027172723.png]]


`e_type` identifiers object file type, `e_machine` identifies target architecture.
#### Relocatable ELF files
A relocatable or shared-object file is considered to be a **collection of sections** as defined in the **section header table**, containing the data necessary to combine file with other object files to form final executable. This table is an array of structures (`Elf32_Shdr` in our case). Every section in the file has exactly one section header describing it. 

The ELF header entry (`e_shoff`) provides the byte offset from the beginning of the file to the section header table, while `e_shentsize` gives the size in bytes of each entry, and `e_shnum` tells how many entries the table contains. 

##### Section Header
The ELF section header, is defined as follows:
![[Pasted image 20251027173124.png]]

| SH field       | Description                                                                                                                                                                                                   |
| -------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `sh_name`      | Specifies the name of the section, given as an index into the section header string table section, yielding a NUL-terminated string.                                                                          |
| `sh_type`      | Categorises the sections contents and semantics.                                                                                                                                                              |
| `sh_flags`     | Holds 1 bit flags describing miscellaneous attributes e.g., occupies memory during process execution, special ordering requirements for link editors, data in section may be merged to eliminate duplication. |
| `sh_addr`      | If the section appears in the process's memory image i.e., is to be loaded, this member gives the virtual address where the first byte should reside.                                                         |
| `sh_offset`    | The byte offset from the beginning of the file to the first byte in the section.                                                                                                                              |
| `sh_size`      | Section's size in bytes                                                                                                                                                                                       |
| `sh_addralign` | Specifies address alignment constraints; the value of `sh_addr` must be congruent to 0, modulo this alignment value.                                                                                          |
| `sh_entsize`   | gives size in bytes of each entry if section holds a table of fixed-size entries, such as a symbol table. Contains 0 if no table.                                                                             |

###### Section Types `sh_type`
Section types categorise the semantics of a given sections contents and appear as a member in its header. Common section types include:

| Section Type            | Description                                                                                                                                                                                                               |
| ----------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `SHT_NULL`              | Marks section header as inactive; does not have associated section.                                                                                                                                                       |
| `SHT_PROGBITS`          | The section holds information defined by the program, such as executable code, read-only data; format and meaning determined solely by the program.                                                                       |
| `SHT_SYMTAB/SHT_DYNSYM` | These sections hold a symbol table. Typically, `SHT_SYMTAB` provides symbols for link editing. Consequently, an object file may also contain a `SHT_DYNSYM` section, which holds a minimal set of dynamic linking symbol. |
| `SHT_STRTAB`            | The section holds a string table. An object file may have multiple string table sections.                                                                                                                                 |
| `SHT_RELA`              | Section holds relocation entries with explicit addends. An object file may have multiple relocation sections.                                                                                                             |
| `SHT_DYNAMIC`           | Section holds information for dynamic linking.                                                                                                                                                                            |
| `SHT_NOTE`              | Section holds information that marks the file in some way.                                                                                                                                                                |
| `SHT_NOBITS`            | A section of this type occupies no space in the file, but otherwise resembles `SHT_PROGBITS`. The `sh_offset` field in header contains conceptual offset from beginning of file, though occupies no bytes.                |
| `SHT_REL`               | Section holds relocation entries without explicit addends.                                                                                                                                                                |
| `SHT_INIT_ARRAY`        | This section contains an array of pointers to initialisation functions. Each pointer in the array is taken as a parameterless procedure with a void return.                                                               |
| `SHT_FINI_ARRAY`        | Section contains an array of pointers to termination functions. Each pointer in the array is taken as a parameterless procedure with a void return.                                                                       |
| `SHT_PREINIT_ARRAY`     | Section contains an array of pointers to functions that are invoked before all other initialisation functions. Each pointer in the array taken as a parameterless procedure with a void return.                           |
| `SHT_GROUP`             | Defines a section group; a set of sections that are related and must be treated specially by the linker. Only appear in relocatable objects, that is, objects with the ELF header member `e_type` set to `ET_REL`.        |

###### Sidenote: Relocation: Rel vs Rela
REL entries within `.rel{name}` section of type `SHT_REL` are relocation entries without explicit addends. The standard struct is `Elf32_Rel`:
```C
typedef struct {
	Elf32_Addr r_offset;
	Elf32_Word r_info;
} Elf32_Rel;
```
`r_offset`-gives location at which to apply relocation action, for relocatable file, the value is the byte offset from the beginning of the section to the unit affected by the relocation. For executable or shared object, the value is the virtual address.

`r_info` - gives both the symbol table index with respect to which the relocation must be made, and the type of relocation to apply. For example, a call instruction relocation entry would hold the symbol table index of the function being called.  Relocation types are processor specific.

```C
typedef struct {
	Elf32_Addr  r_offset;
	Elf32_Word  r_info;
	Elf32_Sword r_addend;
} Elf32_Rela;
```
`r_addend` - specifies a constant addend used to compute the value to be stored into the relocatable field. 


The typical application of an ELF relocation is to determine the referenced symbol value, extract the addend (either from field to be relocated or from addend field contained in relocation record), apply the expression implied by relocation type to symbol and addend, extract desired part of the expression result, place it in field to be relocated. 
###### Section Attribute Flags `sh_flag`
`sh_flags`, single member of given section header of type `Elf32_Word` and contains 1 bit flags that describe miscellaneous attributes of a given section:

| Flag             | Value  | Description                                                                                                                          |
| ---------------- | ------ | ------------------------------------------------------------------------------------------------------------------------------------ |
| `SHF_WRITE`      | `0x1`  | Section contains data that should be writable during process execution                                                               |
| `SHF_ALLOC`      | `0x2`  | Section occupies memory during process execution. Some control sections do without this flag thus do not reside in the memory image. |
| `SHF_EXECINSTR`  | `0x4`  | Section contains executable machine instructions.                                                                                    |
| `SHF_MERGE`      | `0x10` | The data in this section may be merged to eliminate duplication.                                                                     |
| `SHF_STRINGS`    | `0x20` | The data elements consist of null-terminated character strings. This is often used alongside `SHF_MERGE`                             |
| `SHF_LINK_ORDER` | `0x40` | Imposes special ordering requirements for link editors if the section is combined with others.                                       |
| `SHF_GROUP`      | —      | Indices the section is a member of a section group.                                                                                  |

If the flag bit is set in `sh_flags` the attribute is 'on' for that section. 

###### Sections 
In a relocatable ELF file(`e_type = ET_REL`), a section contains all the information in the file bar the ELF header, program header table(optional), and the section header table. 

Each section occupies one contiguous sequence of bytes within the file. Importantly, sections in a file cannot overlap.

Every section in an object file has exactly one section header (`ELF32_Shdr` structures) describing it in the section header table. 

Various sections hold program and control information. The following details the sections that are used by the system and have indicated types and attributes:

| Section                       | Description                                                                                                                                                                                                                                                      | Type             | Flags                           |
| ----------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------- | ------------------------------- |
| `.bss`                        | Holds uninitialised data that contributes to the program's memory image. Occupies no file space.                                                                                                                                                                 | `SHT_NOBITS`     | `SHF_ALLOC`<br>+`SHF_WRITE`     |
| `.comment`                    | Holds version control information.                                                                                                                                                                                                                               | `SHT_PROGBITS`   | none                            |
| `.data/.data1`                | Hold initialised data that contribute to program memory image.                                                                                                                                                                                                   | `SHT_PROGBITS`   | `SHF_ALLOC`<br>+`SHF_WRITE`     |
| `.text/1`                     | Holds the executable instructions of a program.                                                                                                                                                                                                                  | `SHT_PROGBITS`   | `SHF_ALLOC`<br>+`SHF_EXECINSTR` |
| `.debug`                      | Holds info for symbolic debugging.                                                                                                                                                                                                                               | `SHT_PROGBITS`   | none                            |
| `.rodata/1`                   | Hold read only data that typically contribute to non-writable segment in process image.                                                                                                                                                                          | `SHT_PROGBITS`   | `SHF_ALLOC`                     |
| `.rel{name}`<br>`.rela{name}` | Hold relocation information as defined by `Elf32_Rel`. If file has a loadable segment that includes relocation, section's attribute will include `SHF_ALLOC` bit; otherwise off. Conventionally, name is supplied by the section to which the relocations apply. | `SHT_REL/A`<br>  | `SHF_ALLOC` (see desc)          |
| `.interp`                     | Holds path name of program interpreter.                                                                                                                                                                                                                          | `SHT_PROGBITS`   | `SHF_ALLOC`, depends            |
| `.symtab`                     | Holds `Elf32_Sym` table providing symbol information for link editing. If file had loadable segment that includes `.symtab`, sections attributes will include `SHF_ALLOC bit`; otherwise off.                                                                    | `SHT_SYMTAB`     | `SHF_ALLOC`, (see desc)         |
| `.dynsym`                     | Holds dynamic linking symbol table.                                                                                                                                                                                                                              | `SHT_DYNSYM`     | `SHF_ALLOC`                     |
| `.strtab`                     | Holds strings, most commonly the strings that will represent the names associated with symbol table entries. If the file has a loadable segment that includes `.strtab`, section's attributes will include `SHF_ALLOC` bit, otherwise off.                       | `SHT_STRTAB`     | `SHF_ALLOC` (see desc)          |
| `.dynstr`                     | Holds strings needed for dynamic linking, most commonly strings that represent the names associated with symbol table entries.                                                                                                                                   | `SHT_STRTAB`     | `SHF_ALLOC`                     |
| `.got`                        | Holds the global offset table.                                                                                                                                                                                                                                   | `SHT_PROGBITS`   |                                 |
| `.init`                       | Holds executable instructions that contribute to process initialisation code. When program runs, system arranges to execute code in `.init` before calling entry point.                                                                                          | `SHT_PROGBITS`   | `SHF_ALLOC`<br>+`SHF_EXECINSTR` |
| `.init_array`                 | Holds array of function pointers that contribute to a single initialisation array.                                                                                                                                                                               | `SHT_INIT_ARRAY` | `SHF_ALLOC` + `SHF_WRITE`       |
| `.fini`                       | Holds executable instructions that contribute to process termination code. When program exits normally, system arranges to execute code in this section afterwards.                                                                                              | `SHT_PROGBITS`   | `SHF_ALLOC`<br>+`SHF_EXECINSTR` |
| `.fini_array`                 | Holds array of function pointers that contribute to single termination array for the executable or shared object containing the section within a segment.                                                                                                        | `SHT_FINI_ARRAY` | `SHF_ALLOC` + `SHF_WRITE`       |
| `.line`                       | Holds line number information for symbolic debugging.                                                                                                                                                                                                            | `SHT_PROGBITS`   | none                            |
`.interp` in practice used to call the run-time dynamic linker to load the program and to link in any required shared libraries.

ELF symbol table is similar to `a.out` symbol table. It consists of an array of entries `Elf32_Sym`:
```C
typedef struct {
	Elf32_Word    st_name;
	Elf32_Addr    st_value;
	Elf32_Word    st_size;
	unsigned char st_info;
	unsigned char st_other
	Elf32_Half    st_shndx;
} ELF32_Sym;
```

| Field      | Description                                                                                                                                                                                                                                                                                            |
| ---------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `st_name`  | Holds index into object file symbol string table - yields NUL-Terminated representation of symbol name.                                                                                                                                                                                                |
| `st_value` | Gives value of associated symbol; depending on context, may be absolute value, an address etc. Holds file interpretation in linkable format, holds memory interpretation/virtual address in executable format.                                                                                         |
| `st_size`  | Gives size of associated symbol; 0 if no size or unknown size                                                                                                                                                                                                                                          |
| `st_info`  | Specifies symbol's type and binding attributes; type is normally a data object(`STT_OBJECT`) or function(`STT_FUNC`). A binding determines object file scope. Local = visible to object file only, global = visible to all, weak resemble global symbols, but their definitions have lower precedence. |
| `st_other` | Specifies symbol visibility.                                                                                                                                                                                                                                                                           |
| `st_shndx` | Every symbol table entry defined in relation to some section; this member holds the relevant section header table index.                                                                                                                                                                               |

##### Final Diagram
![[Pasted image 20251027220549.png]]






#### Executable ELF files 
Another type of object file specified by ELF `ET_EXEC`, alongside relocatable files and shared object files. An executable files holds a program that is ready for execution and specifies how the system creates a program's process image. Relies primarily on the **Execution View**.

An executable file contains a **program header table**; an array of structures (`Elf32_Phdr`), with each header/structure describing a segment or other information the system needs in order to prepare the program for execution. This header table is only meaningful for executable and shared object files. File specifies program header size with the ELF header's `e_phentsize` and `e_phnum` members. 

An object file segment contains one or more sections as described by a section header table. 
	![[Pasted image 20251027225035.png]]

##### Program Header
```C
typedef struct {
	Elf32_Word	p_type;
	Elf32_Off	p_offset;
	Elf32_Addr	p_vaddr;
	Elf32_Addr	p_paddr;
	Elf32_Word	p_filesz;
	Elf32_Word	p_memsz;
	Elf32_Word	p_flags;
	Elf32_Word	p_align;
} Elf32_Phdr;
```

| Field      | Description                                                                                                                                                                                                                                                                                                                                                            |
| ---------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `p_type`   | Denotes what kind of segment this array element describes.                                                                                                                                                                                                                                                                                                             |
| `p_offset` | Gives the offset from the beginning of the file at which the first byte of the segment resides.                                                                                                                                                                                                                                                                        |
| `p_vaddr`  | This member gives the virtual address at which the first byte of the segment resides in memory. Where to map segment.                                                                                                                                                                                                                                                  |
| `p_paddr`  | On systems for which physical addressing is relevant, this member is reserved for the segment's physical address.                                                                                                                                                                                                                                                      |
| `p_filesz` | This member gives the number of bytes in the file image of the segment; it may be 0.                                                                                                                                                                                                                                                                                   |
| `p_memsz`  | This member gives the number of bytes in the memory image of the segment; it may be 0.                                                                                                                                                                                                                                                                                 |
| `p_flags`  | This member gives flags relevant to the segment.                                                                                                                                                                                                                                                                                                                       |
| `p_align`  | This member gives the value to which the segments are aligned in memory and in the file. Values 0 and 1 mean no alignment is required. Otherwise, should be a positive power of 2, and `p_vaddr` should equal `p_offset` modulo `p_align`. A segment can start and end at arbitrary file offsets, but the virtual starting address is subject to the above constraint. |
###### Segment Types
| Name         | Value | Description                                                                                                                                                                                                                                                                                         |
| ------------ | ----- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `PT_NULL`    | 0     | Array element is unused; lets program header table have ignored entries.                                                                                                                                                                                                                            |
| `PT_LOAD`    | 1     | Specifies loadable segment, described by `p_filesz` and `p_memsz`. Bytes from the file are memory mapped to the beginning of the memory segment. If the segments memory size is larger than the file size, the extra bytes are defined to hold the value and follow the segment's initialised area. |
| `PT_DYNAMIC` | 2     | Specifies dynamic linking information.                                                                                                                                                                                                                                                              |
| `PT_INTERP`  | 3     | Specifies location and size of null-terminated path to invoke an interpreter. If present, must precede any loadable segment entry, to load this instead of main program.                                                                                                                            |
| `PT_NOTE`    | 4     | Specifies location and size of auxilary info.                                                                                                                                                                                                                                                       |
| `PT_SHLIB`   | 5     | Reserved but has unspecified semantics.                                                                                                                                                                                                                                                             |
| `PT_PHDR`    | 6     | Specifies location and size of program header table itself; segment type may not occur more than once in a file.                                                                                                                                                                                    |

###### Loading Process
*Sidenote:*
	*ELF files extend the header in the address space trick used in QMAGIC a.out (file headers considered logically part of `.text` segment, code begins immediately after headers, located in same physical disk page, by mapping this, load headers + beginning of text segment in single operation) files to make executable files as compact as possible at the cost of some unused space in the address space.* 

Execution view segments are arranged such that all loadable sections are packed into their appropriate segments to minimise loading operations e.g., the mapped text segment consists of an ELF header, the program header, and read-only text.

Executable files usually have all relocation done and all symbols resolved, except possibly symbols related to shared libraries which are resolved at runtime. Typically linked to load at fixed addresses, thus relocation unnecessary unless rely on PIC code or dynamic linking.

As described above a segment can start and end at arbitrary file offsets, but the virtual starting address is subject to the above constraint (`p_vaddr = (p_offset % p_align)`).

File chunks are memory mapped, which involves the system reading the program header to map file pages associated with segments into the process' address space  according to `p_vaddr` and `p_memsz`, with appropriate permissions for mapped ranges of pages. For example, executable code and read-only data typically mapped as RO, but read/write data is mapped as copy-on-write.

![[Pasted image 20251028185754.png]]
There may be overlap between the contiguous segments on file, when mapped into process image, to save space and preserve alignment e.g., map .rodata section if small into last .text segment page prior to load by assigning p_vaddr that reflect this.

The BSS section holds uninitialised data that should be initialised to zero by the system when the program begins to run. Occupies memory(`SHF_ALLOC`) but uses no space in the file itself (`SHT_NOBITS`). BSS is logically contiguous with read/write section in data segment, begins immediately after last byte of initialised data.  Writable data segments typically mapped copy-on-write by OS. BSS is initialised when program starts, writes zeros to this segment, thus triggers COW system, making private copy of that page for the process, ensuring process can write data without corrupting the shared file-backed memory page used by other processes.

#### ELF Shared Object
Contains all baggage of relocatable view and executable view of ELF file. Since intended to be run, must contain program header table. Since intended to be linked with other files, it holds relocation information, symbol tables, other data, defined according to section header table.

